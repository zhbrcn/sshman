name: Auto-merge Codex PRs (Turbo)

on:
  # 1. 极速触发：只要 codex 分支有代码推送，立即运行！
  push:
    branches:
      - 'codex/**'
  # 2. 标准触发：PR 变动时触发 (作为备份)
  pull_request:
    branches:
      - main
    types: [ opened, synchronize, reopened ]
  # 3. 保底触发：每 5 分钟自动巡逻一次 (GitHub 允许的最快频率)
  schedule:
    - cron: '*/5 * * * *'
  # 4. 手动开关
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write

jobs:
  auto-merge:
    runs-on: ubuntu-latest
    # 只要满足任一条件就运行
    if: |
      github.event_name == 'schedule' || 
      github.event_name == 'workflow_dispatch' || 
      startsWith(github.ref, 'refs/heads/codex/') || 
      startsWith(github.head_ref, 'codex/')

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          # 必须使用全局 Secret (AUTO_MERGE_TOKEN) 以确保有权限推送
          token: ${{ secrets.AUTO_MERGE_TOKEN }} 

      - name: 确定合并源 (自动识别分支或PR)
        id: get_source
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TARGET_BRANCH=""
          PR_NUMBER=""

          # 情况 A: 由 Push 事件触发 (速度最快)
          if [[ "${{ github.event_name }}" == "push" ]]; then
            # 提取分支名 (去掉 refs/heads/ 前缀)
            TARGET_BRANCH=${GITHUB_REF#refs/heads/}
            echo "🔥 Triggered by Push. Branch: $TARGET_BRANCH"
            echo "branch=$TARGET_BRANCH" >> $GITHUB_OUTPUT

          # 情况 B: 由 PR 事件触发
          elif [[ "${{ github.event_name }}" == "pull_request" ]]; then
            TARGET_BRANCH=${{ github.head_ref }}
            PR_NUMBER=${{ github.event.pull_request.number }}
            echo "⚡ Triggered by PR. Branch: $TARGET_BRANCH"
            echo "branch=$TARGET_BRANCH" >> $GITHUB_OUTPUT
            echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT

          # 情况 C: 定时任务或手动触发
          else
            echo "⏰ Triggered by Schedule/Manual. Searching for open Codex PRs..."
            # 查找所有打开的 codex PR，取第一个
            PR_DATA=$(gh pr list --state open --head "codex/" --json number,headRefName --jq '.[0]')
            
            if [[ "$PR_DATA" == "null" || -z "$PR_DATA" ]]; then
              echo "No open Codex PRs found. Skipping."
              echo "found=false" >> $GITHUB_OUTPUT
            else
              PR_NUMBER=$(echo $PR_DATA | jq -r '.number')
              TARGET_BRANCH=$(echo $PR_DATA | jq -r '.headRefName')
              echo "✅ Found PR #$PR_NUMBER on branch $TARGET_BRANCH"
              echo "branch=$TARGET_BRANCH" >> $GITHUB_OUTPUT
              echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
              echo "found=true" >> $GITHUB_OUTPUT
            fi
          fi

      - name: 执行强制合并 (main <- codex)
        # 只有在找到了分支的情况下才执行
        if: steps.get_source.outputs.branch != ''
        run: |
          BRANCH_NAME="${{ steps.get_source.outputs.branch }}"
          echo "🚀 Processing merge for branch: $BRANCH_NAME"

          # 1. 配置 Git 身份
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          
          # 2. 切换到 main
          git checkout main
          
          # 3. 拉取目标分支的最新代码
          git fetch origin $BRANCH_NAME
          
          # 4. 强制合并 (冲突时优先使用 Codex 版本)
          git merge origin/$BRANCH_NAME -X theirs --no-edit

      - name: 备份并推送到 main
        if: steps.get_source.outputs.branch != ''
        run: |
          # 5. 打备份 Tag
          tag="backup-$(date +'%Y%m%d-%H%M%S')"
          git tag $tag
          
          # 6. 推送 main 和 tag
          git push origin main
          git push origin $tag

      - name: 关闭关联的 PR (如果有)
        if: steps.get_source.outputs.pr_number != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_NUM=${{ steps.get_source.outputs.pr_number }}
          echo "Closing PR #$PR_NUM..."
          # 尝试关闭 PR，即使它已经被合并
          gh pr close $PR_NUM --comment "Auto-merged by Codex Turbo Workflow." || true
